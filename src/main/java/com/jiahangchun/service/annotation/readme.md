Annotation分析
SpringApplication.run->
SprigApplication.prepareContext->
BeanDefinitionLoader.load->
AnnotatedBeanDefinitionReader.doRegisterBean->
本来是打算看看Controller怎么注入的，但是又担心BeanDefinitionRegister的实现类太多了，所以打算从SpringBoot入手，尝试着看看。
结果还真找到了关于Controller的注入，在BeanADefinitionReaderUtils中找到最终的结果：BeanDefinitionReadUtils.registerBeanDefinition

根据Debugger反向推测
主要的动作还是在SpringApplication.refresh方法上(SpringApplication.refreshContext)->
ServletWebServerApplicationContext.refresh->
AbstractApplicationContext.invokeBeanFactoryPostProcessors->
PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessor->
PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessors(其实这里面才是我们的重点：Spring在里面加载了个ConfigurationClassPostProcessor进行加载请求)->
ConfigurationClassPostProcessor.processConfigBeanDefinitions(初始化了个对应的处理装置：ConfigurationClassParser，打算用这个东西来处理某个包下面的所有@Component)->
ConfigurationClassParser.processConfigurationClass->
ConfigurationClassParser.doProcessConfigurationClass(这个才是真正的方法：通过不断扫描不同的Annotation作出不同的处理)->
ClassPathBeanDefinitionScanner具体的操作还是由这个类来完成的。扫描某个包下面的某个具体的@Component,然后返回对应的BeanDefinition。感觉真正有用的是findCandidateComponents(basePackage),这里就是找到对应的BeanDefinition
我觉得整个处理过程可能的重点在于 MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource);  
这里面这个ReaderFactory发现是AnnotatedBeanDefinitionReader(和预期的一样：都是根据环境配置获取一个特定的对应的读取类)->
现在将进入具体的将@Component转换成对应的BeanDefinition，然后进入BeanFactory的过程.->
经过debugger,发现实际的操作在SimpleMetadataReader的初始化的过程中，将所有要调用的信息将全部封装在这个MetadataReader当中  
使用的类是AnnotationMetadataReadingVisitor进行解析：但是发现它使用了进行字节码读取的方式进行处理，而不是Java的方法，感觉这点很奇怪。
通过以上的类就能将这个target/目录下的对应的.class文件的全部信息都读取出来。

查阅了相关资料这是由于：要加快速度，通过反射的方式太慢了
ClassReader & ClassVisitor是asm提供的字节码访问类

[spring自动扫描机制](https://blog.csdn.net/liweisnake/article/details/7374858)
[字节码处理框架asm](https://blog.csdn.net/ohcezzz/article/details/78416176)
[手动写Java字节码](http://budairenqin.iteye.com/blog/1771141)







